# 2026-02-12 07:11 - JSON Straitjacket & Logic Traps Feasibility

**Topic:** JSON 拘束衣 (JSON Straitjacket) & 逻辑陷阱 (Logic Traps)
**Focus:** Feasibility & Implementation Strategy

## 1. Feasibility Analysis (可行性分析)

### JSON Straitjacket (JSON 拘束衣)
*   **The Challenge:** Small edge models (Llama-3-8B-4bit, Phi-3-mini) often struggle to output *valid, strict* JSON without yapping ("Here is the JSON you requested...").
*   **WebLLM Constraints:**
    *   Does WebLLM expose `json_mode` or constrained decoding (logits processing) effectively?
    *   *Risk:* Without constrained decoding (grammar-based sampling), we rely purely on prompt engineering ("OUTPUT ONLY JSON"). Failure rate will be high for <7B models.
    *   *Mitigation:* If the engine doesn't support grammar enforcement, we implement a "Robust Parser" in the Judge that extracts JSON from Markdown blocks or raw text, but penalizes the score for "dirty output".

### Logic Traps (逻辑陷阱)
*   **The Challenge:** Context window limits on edge devices.
*   **Execution:**
    *   Need to verify if models hallucinate on false premises ("When did Napoleon use a tank?").
    *   *Performance:* Inference speed is key. If the user waits 2 minutes for a trap question, the "Battle" feeling is lost. Needs to be snappy.

## 2. Implementation Path (实现路径)

### Tech Stack
*   **Framework:** Vue 3 + Vite (Fast, lightweight).
*   **Inference:** `WebLLM` (MLC-LLM) for browser-native execution.
*   **Validation:** `Zod` for strict schema validation. `json-repair` as a fallback (but penalized).

### Module: JSON Straitjacket
*   **Level 1 (Easy):** Flat object. `{"answer": "blue"}`.
*   **Level 2 (Hard):** Nested arrays with specific types.
*   **Level 3 (Torture):** "Recursive Straitjacket". The JSON must contain a stringified JSON inside a specific key, which must be valid.
    *   *Code Idea:*
        ```typescript
        // The Judge
        function judgeOutput(raw: string, schema: ZodSchema) {
          try {
            const parsed = JSON.parse(extractJson(raw));
            const result = schema.safeParse(parsed);
            if (!result.success) return { score: 0, error: result.error };
            if (raw.trim() !== JSON.stringify(parsed)) return { score: 0.8, note: "Contains yapping" }; // Deduct for extra text
            return { score: 1.0 };
          } catch {
            return { score: 0, error: "Invalid JSON" };
          }
        }
        ```

### Module: Logic Traps
*   **Data Structure:**
    ```json
    {
      "id": "trap_001",
      "prompt": "Sally has 3 brothers. Each brother has 2 sisters. How many sisters does Sally have?",
      "trap_type": "logical_consistency",
      "expected_answer_contains": ["1", "one"],
      "anti_answer_contains": ["2", "6", "two", "six"]
    }
    ```

## 3. Evolution & Cuts (演进与删减)

*   **CUT (毙掉):** "Multi-turn Logic Traps" for version 1.
    *   *Reason:* State management in browser-only memory is tricky if the model context gets too big. Keep it single-turn Q&A for the MVP to ensure stability on 8GB RAM machines.
*   **NEW IDEA (新点子):** **"The Yapometer" (废话检测仪)**
    *   Specifically measure how much "conversational filler" a model adds before/after the requested answer.
    *   Lower score for high "Yap" count. Crucial for agentic use cases where token costs matter.
*   **NEW IDEA:** **"Streaming JSON Validator"**
    *   Visualize the validation *in real-time* as the tokens generate. Red background flashes immediately when a syntax error occurs (missing quote, wrong brace). Makes the "Battle" visual.

## Next Steps
1.  Prototype the "Yapometer" using WebLLM simple chat.
2.  Create a dataset of 10 "JSON Hell" prompts.
